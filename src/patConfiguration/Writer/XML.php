<?PHP
/**
 * patConfiguration writer for XML files
 *
 * used by the patConfiguration object to write XML config files
 *
 * $Id: XML.php 23 2005-02-05 16:06:09Z schst $
 *	
 * @package		patConfiguration
 * @subpackage	Writer
 * @author		Stephan Schmidt <schst@php-tools.net>
 */

/**
 * patConfiguration writer for XML files
 *
 * used by the patConfiguration object to write XML config files
 *
 * $Id: XML.php 23 2005-02-05 16:06:09Z schst $
 *	
 * @package		patConfiguration
 * @subpackage	Writer
 * @author		Stephan Schmidt <schst@php-tools.net>
 */
class patConfiguration_Writer_XML extends patConfiguration_Writer
{
   /**
 	* table used for translation of xml special chars
	* @var	array	$xmlSpecialchars
	*/
	var	$xmlSpecialchars	=	array(
										"&"		=>	"&amp;",
										"'"		=>	"&apos;",
										"\""	=>	"&quot;",
										"<"		=>	"&lt;",
										">"		=>	"&gt;"
									);
	
   /**
	* open tags
	* @var	array	$openTags
	*/
	var	$openTags = array();

   /**
	* create an xml representation of the current config
	*
	* @access	private
	* @param	array	$config		config to serialize
	* @param	array	$options	options for the serialization
	* @return	string	$content	xml representation
	*/
	function serializeConfig( $config, $options )
	{
		if (!isset($options["mode"])) {
			$options["mode"] = "plain";
		}

		$this->openTags = array();

		ksort( $config );
		reset( $config );
		
		if ($options["mode"] == "pretty") {
			$options["nl"] = "\n";
		} else {
			$options["nl"] = "";
		}

		$options["depth"] = 0;
		
		$xml  = "<?xml version=\"1.0\" encoding=\"{$this->configObj->encoding}\"?>\n";
		$xml .= "<configuration>".$options["nl"];
		//	add comment in pretty mode
		if ($options["mode"] == "pretty") {
			$xml .=	"\t<!--\n";
			$xml .=	"\t\tConfiguration generated by patConfiguration v".$this->configObj->systemVars["appVersion"]."\n";
			$xml .=	"\t\t(c) ".implode( ",", $this->configObj->systemVars["author"] )."\n";
			$xml .=	"\t\tdownload at http://www.php-tools.net\n";
			$xml .=	"\t\tgenerated on " . date( "Y-m-d H:i:s", time() ) . "\n";
			$xml .=	"\t-->\n";
		}
		++$options["depth"];
		
		foreach ($config as $key => $value) {
			$path = explode( ".", $key );

			switch (count($path)) {
				case 0:
				    patErrorManager::raiseWarning(
					       						PATCONFIGURATION_WARNING_CONFIGVALUE_WITHOUT_NAME,
							     				"configValue without name found!"
								    			 );
				default:
					$openNew = array();
					$tag     = array_pop( $path );
					$start   = max( count( $path ), count( $this->openTags ) );
					
					for ($i=( $start-1 ); $i>=0; $i--) {
						if (!isset( $this->openTags[$i] ) || $path[$i] != $this->openTags[$i]) {
							if (count( $this->openTags ) > 0) {
								array_pop( $this->openTags );
								$options["depth"]--;
								if ($options["mode"] == "pretty") {
									$xml .= str_repeat( "\t", $options["depth"] );
								}
								$xml .= "</path>".$options["nl"];
							}
							if (isset($path[$i])) {
								array_push( $openNew, $path[$i] );
							}
						}
						
					}
							
					while ($path = array_pop($openNew)) {
						array_push( $this->openTags, $path );
						$xml .= str_repeat( "\t", $options["depth"] );
						$xml .= "<path name=\"".$path."\">".$options["nl"];
						$options['depth']++;
					}

					$xml .= $this->createTag( $tag, $value, $options );
					break;
			}
		}

		//	close all open tags
		while ($open = array_pop($this->openTags)) {
			--$options["depth"];
			$xml .= str_repeat( "\t", $options["depth"] );
			$xml .= "</path>".$options["nl"];
		}
		$xml .= "</configuration>";
		return	$xml;
	}

   /**
	* create configValue tag
	*
	* @access	private
	* @param	string	$name 	name attribute of the tag
	* @param	mixed	$value 	value of the tag
	* @return	string	$tag	xml representation of the tag
	*/
	function createTag( $name, $value, $options )
	{
		$atts = array();
		if ($name !== NULL) {
            $atts["name"] = $name;
		}

		if(is_bool($value)) {
			$atts["type"] = "bool";
			$value        = $value ? "true" : "false";
		} elseif (is_float( $value )) {
			$atts["type"] = "float";
		} elseif (is_int( $value )) {
			$atts["type"] = "int";
		} elseif (is_array($value)) {
			$atts["type"] = "array";
		} elseif (is_string( $value )) {
			$atts["type"] = "string";
		}

		$tag = '';
		if ($options["mode"] == "pretty") {
			$tag .= str_repeat( "\t", $options["depth"] );
		}
		$tag .= "<configValue";

		if( is_array( $atts ) ) {
		    foreach ($atts as $att => $val) {
				$tag .= " ".$att."=\"".$val."\"";
		    }
		}
		
		if (!$value) {
			$tag .= "/>".$options["nl"];
		} else {
			$tag .= ">";

			if (is_array($value)) {
				++$options['depth'];

				$tag .= $options["nl"];
				foreach ($value as $key => $val) {
					if (is_int($key)) {
						$key = NULL;
					}
					$tag .= $this->createTag( $key, $val, $options );
				}

				--$options["depth"];
				if ($options["mode"] == "pretty") {
					$tag .= str_repeat( "\t", $options["depth"] );
				}
			} else {
				$tag .= $this->replaceXMLSpecialchars( $value );
			}

			$tag .= "</configValue>".$options["nl"];
		}
		return	$tag;
	}
	
   /**
	* replace XML special chars
	*
	* @param	string	$string		string, where special chars should be replaced
	* @param	array	$table		table used for replacing
	* @return	string	$string		string with replaced chars
	*/
	function replaceXMLSpecialchars( $string, $table = array() )
	{
		if (empty($table)) {
			$table = &$this->xmlSpecialchars;
		}

		$string	= strtr( $string, $table );

		return	$string;
	}
}
?>